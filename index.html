<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>SQLAlchemy Core: An Introduction</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>SQLAlchemy Core</h1>
          <h2>An Introduction</h2>
          <p>
            <small><a href="http://jasonamyers.com">Jason Myers</a> / <a href="http://twitter.com/jasonamyers">@jasonamyers</a></small>
          </p>
          <br>
          <p>
            <small>Background by maul555</small>
          </p>
          <aside class="notes">Welcome, How do I describe SQLAlchemy? Well?</aside>
        </section>

        <section>
          <img src="Awesome.gif">
          </img>
          <aside class="notes">It has a ton of very, very useful functions and while not everything is not a nail it solves a ton of common problems for me. Let’s talk about about how its put together.</aside>
        </section>

        <section>
          <section>
            <h2>Differences between Core and ORM</h2>
            <aside class="notes">The base of SQLAlchemy is the dialect and it’s handshake with the actual drivers via connection pools, the dialect along with schema introspection and typing enables us to use a python friendly SQL Expression language. All of these components are considered the Core of SQL Alchemy. Then we have a very rich ORM built on top of that foundation. If you TL;DR that ... it’s like GIT</aside>
          </section>
          <section>
            <h2>ORM - Domain Model</h2>
            <pre><code data-trim class="language-python">
class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    name = Column(String)
    fullname = Column(String)
    password = Column(String)
            </code></pre>
            <aside class="notes">The base of SQLAlchemy is the dialect and it’s handshake with the actual drivers via connection pools, the dialect along with schema introspection and typing enables us to use a python friendly SQL Expression language. All of these components are considered the Core of SQL Alchemy. Then we have a very rich ORM built on top of that foundation. If you TL;DR that ... it’s like GIT</aside>
          </section>
          <section>
            <h2>Core - Schema-centric Model</h2>
            <pre><code data-trim class="language-python">
from sqlalchemy import Table, Column, Integer, String, MetaData
metadata = MetaData()
users = Table('users', metadata,
    Column('id', Integer, primary_key=True),
    Column('name', String),
    Column('fullname', String),
)
            </code></pre>
            <aside class="notes">The base of SQLAlchemy is the dialect and it’s handshake with the actual drivers via connection pools, the dialect along with schema introspection and typing enables us to use a python friendly SQL Expression language. All of these components are considered the Core of SQL Alchemy. Then we have a very rich ORM built on top of that foundation. If you TL;DR that ... it’s like GIT</aside>
          </section>
        </section>

        <section>
          <section>
            <h2>Structure</h2>
            <img src="layers.png"></img>
            <aside class="notes">The base of SQLAlchemy is the dialect and it’s handshake with the actual drivers via connection pools, the dialect along with schema introspection and typing enables us to use a python friendly SQL Expression language. All of these components are considered the Core of SQL Alchemy. Then we have a very rich ORM built on top of that foundation. If you TL;DR that ... it’s like GIT</aside>
          </section>
          <section>
            <img src="idea-01.jpg"></img>
            <aside class="notes">Much like people describe git, there is plumbing and porcelain, and both are useful depending on your needs. The ORM has some similarities to Django’s ORM, and is very useful when you have a user built model of the data. However, both of them fall down when that isn't the case, and that's where SQLAlchemy Core really shines.</aside>
          </section>
        </section>
        <section>
          <section>
            <h2>Installing</h2>
            <p>pip install sqlalchemy</p>
            <p class="fragment">pip install flask-sqlalchemy</p>
            <p class="fragment">bin/paster create -t pyramid_alchemy tutorial</p>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
          <section>
            <h2>Initializing</h2>
            <pre><code data-trim class="language-python">
import sqlalchemy
from sqlalchemy import create_engine
engine = create_engine('sqlite:///:memory:', echo=True)
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
        </section>
        <section>
          <h2>Defining a Table</h2>
          <pre><code data-trim class="language-python">
from sqlalchemy import Table, Column, Integer, String, MetaData, ForeignKey
metadata = MetaData()
actors = Table('actors', metadata,
    Column('id', Integer, primary_key=True),
    Column('name', String),
    Column('fullname', String),
)
roles = Table('roles', metadata,
    Column('id', Integer, primary_key=True),
    Column('actor_id', None, ForeignKey('actors.id')),
    Column('character_name', String, nullable=False)
)
          </code></pre>
          <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
        </section>
        <section>
          <h2>Create the tables</h2>
          <pre><code data-trim class="language-python">
metadata.create_all(engine)
          </code></pre>
          <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
        </section>
        <section>
          <h2>Open a connection</h2>
          <pre><code data-trim class="language-python">
conn = engine.connect()
          </code></pre>
          <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
        </section>
        <section>
          <section>
            <h2>Single Insert</h2>
            <pre><code data-trim class="language-python">
ins = actors.insert().values(name='Graham', fullname='Graham Chapman')
result = conn.execute(ins)
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
          <section>
            <h2>Multiple Insert</h2>
            <pre><code data-trim class="language-python">
conn.execute(roles.insert(), [
    {'actor_id': 1, 'character_name' : 'King Arthur'},
    {'actor_id': 1, 'character_name' : 'Voice of God'},
    {'actor_id': 2, 'character_name' : 'Sir Lancelot'},
    {'actor_id': 2, 'character_name' : 'Black Knight'},
    {'actor_id': 3, 'character_name' : 'Patsy'},
    {'actor_id': 3, 'character_name' : 'Sir Bors'},
])
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
          <section>
            <h2>Selecting</h2>
            <pre><code data-trim class="language-python">
from sqlalchemy.sql import select
s = select([actors])
result = conn.execute(s)
for row in result:
    print row

(1, u'Graham', u'Graham Chapman')
(2, u'John', u'John Cleese')
(3, u'Terry', u'Terry Gilliam')
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
          <section>
            <h2>Selecting</h2>
            <pre><code data-trim class="language-python">
s = select([actors.c.name, actors.c.fullname])
result = conn.execute(s)
for row in result:
    print row

(u'Graham', u'Graham Chapman')
(u'John', u'John Cleese')
(u'Terry', u'Terry Gilliam')
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
          <section>
            <h2>Update</h2>
            <pre><code data-trim class="language-python">
stmt = actors.update().\
    where(actors.c.name == 'Graham').\
    values(name='Gram')

conn.execute(stmt)
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
          <section>
            <h2>Delete</h2>
            <pre><code data-trim class="language-python">
result = conn.execute(actors.delete().where(actors.c.name == 'Terry'))
result.rowcount

1
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
          <section>
            <h2>Ordering</h2>
            <pre><code data-trim class="language-python">
stmt = select([actors.c.name]).order_by(actors.c.name.desc())
conn.execute(stmt).fetchall()

[(u'Terry',), (u'John',), (u'Graham',)]
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
          <section>
            <h2>Filtering</h2>
            <pre><code data-trim class="language-python">
from sqlalchemy.sql import and_, or_, not_
stmt = select([actors.c.name, roles.c.character_name]).\
    where(
        and_(
          actors.c.name.like('Gra%'),
          roles.c.character_name.like('Vo%')
        )
    )
conn.execute(stmt).fetchall()

[(u'Graham', u'Voice of God')]
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
          <section>
            <h2>Limiting</h2>
            <pre><code data-trim class="language-python">
stmt = select([actors.c.name, roles.c.character_name]).\
    select_from(actors.join(roles)).\
    limit(1).offset(1)
conn.execute(stmt).fetchall()

[(u'Graham', u'Voice of God')]
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
        </section>
        <section>
          <section>
            <h2>Count</h2>
            <pre><code data-trim class="language-python">
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
          <section>
            <h2>Sum</h2>
            <pre><code data-trim class="language-python">
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
        </section>
          <section>
            <h2>Grouping</h2>
            <pre><code data-trim class="language-python">
stmt = select([actors.c.name, func.count(roles.c.id)]).\
    select_from(actors.join(roles)).\
    group_by(actors.c.name)
conn.execute(stmt).fetchall()

[(u'Graham', 2), (u'John', 2), (u'Terry', 2)]
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
        <section>
          <section>
            <h2>Joins</h2>
            <pre><code data-trim class="language-python">
s = select([actors, roles]).where(actors.c.id == roles.c.actor_id)
for row in conn.execute(s):
    print row

(1, u'Graham', u'Graham Chapman', 1, 1, u'King Arthur')
(1, u'Graham', u'Graham Chapman', 2, 1, u'Voice of God')
(2, u'John', u'John Cleese', 3, 2, u'Sir Lancelot')
(2, u'John', u'John Cleese', 4, 2, u'Black Knight')
(3, u'Terry', u'Terry Gilliam', 5, 3, u'Patsy')
(3, u'Terry', u'Terry Gilliam', 6, 3, u'Sir Bors')
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
          <section>
            <h2>Unions</h2>
            <pre><code data-trim class="language-python">
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
        </section>
        <section>
          <section data-background="dialect.jpg">
            <aside class="notes">in addition to column types, the dialects define sql commands, their parameters loosely they are validated by the database driver and by sending the actual command to the DB.</aside>
          </section>
          <section>
            <h2>Common Dialects</h2>
            <ul>
              <li>Informix</li>
              <li>MS SQL</li>
              <li>Oracle</li>
              <li>Postgres</li>
              <li>SQLite</li>
              <li>Custom</li>
            </ul>
            <aside class="notes">Most common systems are covered, and customizing them is fairly easy. For example at work we use redshift, and we’ve been writing a sqlalchemy_redshift dialect. Which you can download on github. So let’s query some data...</aside>
          </section>
          <section>
            <h2>But what if...</h2>
            <pre><code data-trim class="language-python">
class UnloadFromSelect(Executable, ClauseElement):

    def __init__(self, select, bucket, access_key, secret_key):
        self.select = select
        self.bucket = bucket
        self.access_key = access_key
        self.secret_key = secret_key

@compiles(UnloadFromSelect)
def visit_unload_from_select(element, compiler, **kw):
    return "unload ('%(query)s') to '%(bucket)s'
        credentials 'aws_access_key_id=%(access_key)s;
        aws_secret_access_key=%(secret_key)s' delimiter ','
        addquotes allowoverwrite" % {
        'query': compiler.process(element.select,
              unload_select=True, literal_binds=True),
        'bucket': element.bucket,
        'access_key': element.access_key,
        'secret_key': element.secret_key,
    }</code></pre>
        <aside class="notes">Here is an example of a single statement for a custom dialect. It establishes an unload from command as seen in Amazon Redshift</aside>
        </section>

          <section>
            <pre><code data-trim class="language-python">
unload = UnloadFromSelect(
    select([fields]),
    '/'.join(['s3:/', BUCKET, filename]),
    ACCESS_KEY,
    SECRET_KEY
)
            </code></pre>
            <aside class="notes">Example Usage</aside>
          </section>
          <section>
          <pre><code data-trim class="language-python">
unload (
  'select * from venue where venueid in (
        select venueid from venue order by venueid desc limit 10)'
)
to 's3://mybucket/venue_pipe_'
credentials 'aws_access_key_id=ACCESS_KEY;
  aws_secret_access_key=SECRET_KEY';
</code></pre>
          <aside class="notes">Generated Statement</aside>
          </section>
        </section>
        <section>
          <h2>Dynamic Table Introspection</h2>
          <pre><code data-trim class="language-python">
def build_table(engine, table_name):
    return Table(table_name, metadata, autoload=True, autoload_with=engine)
          </code></pre>
          <aside class="notes">This introspection makes a table from a given engine and metadata collection.</aside>
        </section>
        <section>
          <pre><code>
build_table('census')
unavailable_fields = [
    c.name for c in t.c if isinstance(c.type, NullType)
]
          </code></pre>
          <aside class="notes">Once you build the table, it’s important to check for fields that have a null type as they can have an unexpected affect on code. NullType fields are found because a column type doesn’t match a SQLAlchemy column type in the dialect being used.</aside>
        </section>
        <section>
          <section>
            <h2>Chaining</h2>
            <pre><code data-trim class="language-python">
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
          <section>
            <h2>Conditionals</h2>
            <pre><code data-trim class="language-python">
            </code></pre>
            <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
          </section>
        </section>
        <section>
          <h2>Questions</h2>
          <pre><code data-trim class="language-python">
          </code></pre>
          <aside class="notes">In many cases you’ll just pip install SQLAlchemy. but if you’re using flask I recommend using the variant just for it and pyramid has a scaffold for SQLAlchemy as well</aside>
        </section>
      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
         parallaxBackgroundImage: 'background.jpg',
         parallaxBackgroundSize: '5760px 3240px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
